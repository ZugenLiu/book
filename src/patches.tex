%	$Id: patches.tex,v 1.4 2012/08/06 13:37:54 pooka Exp $

\section{Patches to the 5.99.48 source tree}

Fix a compilation error in code which is not compiled by default:

{\tt \scriptsize
\begin{verbatim}
Index: sys/rump/librump/rumpkern/locks_up.c
===================================================================
RCS file: /usr/allsrc/repo/src/sys/rump/librump/rumpkern/locks_up.c,v
retrieving revision 1.5
diff -p -u -r1.5 locks_up.c
--- sys/rump/librump/rumpkern/locks_up.c        1 Dec 2010 17:22:51 -0000       1.5
+++ sys/rump/librump/rumpkern/locks_up.c        2 Dec 2011 16:40:00 -0000
@@ -160,6 +160,7 @@ mutex_owned(kmutex_t *mtx)
 struct lwp *
 mutex_owner(kmutex_t *mtx)
 {
+       UPMTX(mtx);
 
        return upm->upm_owner;
 }
\end{verbatim}}


Fix a locking error in a branch which is not hit during normal execution:

{\tt \scriptsize
\begin{verbatim}
Index: sys/rump/librump/rumpkern/vm.c
===================================================================
RCS file: /usr/allsrc/repo/src/sys/rump/librump/rumpkern/vm.c,v
retrieving revision 1.114
diff -u -r1.114 vm.c
--- sys/rump/librump/rumpkern/vm.c        21 Mar 2011 16:41:08 -0000      1.114
+++ sys/rump/librump/rumpkern/vm.c        12 Dec 2011 14:16:02 -0000
@@ -1132,7 +1132,6 @@
                        rumpuser_dprintf("pagedaemoness: failed to reclaim "
                            "memory ... sleeping (deadlock?)\n");
                        cv_timedwait(&pdaemoncv, &pdaemonmtx, hz);
-                       mutex_enter(&pdaemonmtx);
                }
        }
 
\end{verbatim}}
\clearpage

This is a quick fix for making it possible to link rump kernels
which do not include the VFS faction, but include components which
want to create device nodes.  A more thorough fix should not use
weak symbols and examine the call sites as well --- the stubs the
calls are aliased to return a failure, and not all callers tolerate
that.

{\tt \scriptsize
\begin{verbatim}
Index: sys/rump/librump/rumpkern/rump.c
===================================================================
RCS file: /usr/allsrc/repo/src/sys/rump/librump/rumpkern/rump.c,v
retrieving revision 1.234
diff -p -u -r1.234 rump.c
--- sys/rump/librump/rumpkern/rump.c      22 Mar 2011 15:16:23 -0000      1.234
+++ sys/rump/librump/rumpkern/rump.c      5 Jan 2012 23:42:17 -0000
@@ -160,6 +161,9 @@
 rump_proc_vfs_init_fn rump_proc_vfs_init;
 rump_proc_vfs_release_fn rump_proc_vfs_release;
 
+__weak_alias(rump_vfs_makeonedevnode,rump__unavailable);
+__weak_alias(rump_vfs_makedevnodes,rump__unavailable);
+
 static void add_linkedin_modules(const struct modinfo *const *, size_t);
 
 static void __noinline
\end{verbatim}}

The following patch fixes the faster I/O mode for ukfs(3).  It was
written to produce the minimal diff.

{\tt \scriptsize
\begin{verbatim}
Index: lib/libukfs/ukfs.c
===================================================================
RCS file: /cvsroot/src/lib/libukfs/ukfs.c,v
retrieving revision 1.57
diff -p -u -r1.57 ukfs.c
--- lib/libukfs/ukfs.c  22 Feb 2011 15:42:15 -0000      1.57
+++ lib/libukfs/ukfs.c  5 Jul 2012 20:53:34 -0000
@@ -115,14 +115,18 @@ ukfs_getspecific(struct ukfs *ukfs)
 #endif

 static int
-precall(struct ukfs *ukfs, struct lwp **curlwp)
+precall(struct ukfs *ukfs, struct lwp **curlwp, bool sharefd)
 {
+       int rfflags = 0;
+
+       if (!sharefd)
+               rfflags = RUMP_RFCFDG;

        /* save previous.  ensure start from pristine context */
        *curlwp = rump_pub_lwproc_curlwp();
        if (*curlwp)
                rump_pub_lwproc_switch(ukfs->ukfs_lwp);
-       rump_pub_lwproc_rfork(RUMP_RFCFDG);
+       rump_pub_lwproc_rfork(rfflags);

        if (rump_sys_chroot(ukfs->ukfs_mountpath) == -1)
                return errno;
@@ -145,7 +149,17 @@ postcall(struct lwp *curlwp)
 struct lwp *ukfs_curlwp;                                               \
 do {                                                                   \
        int ukfs_rv;                                                    \
-       if ((ukfs_rv = precall(ukfs, &ukfs_curlwp)) != 0) {             \
+       if ((ukfs_rv = precall(ukfs, &ukfs_curlwp, false)) != 0) {      \
+               errno = ukfs_rv;                                        \
+               return -1;                                              \
+       }                                                               \
+} while (/*CONSTCOND*/0)
+
+#define PRECALL2()                                                     \
+struct lwp *ukfs_curlwp;                                               \
+do {                                                                   \
+       int ukfs_rv;                                                    \
+       if ((ukfs_rv = precall(ukfs, &ukfs_curlwp, true)) != 0) {       \
                errno = ukfs_rv;                                        \
                return -1;                                              \
        }                                                               \
@@ -848,7 +862,7 @@ ukfs_open(struct ukfs *ukfs, const char
 {
        int fd;

-       PRECALL();
+       PRECALL2();
        fd = rump_sys_open(filename, flags, 0);
        POSTCALL();
        if (fd == -1)
\end{verbatim}}

This fixes the conditionally compiled block device layer host direct
I/O support.

{\tt \scriptsize
\begin{verbatim}
Index: sys/rump/librump/rumpvfs/rumpblk.c
===================================================================
RCS file: /usr/allsrc/repo/src/sys/rump/librump/rumpvfs/rumpblk.c,v
retrieving revision 1.46
diff -p -u -r1.46 rumpblk.c
--- sys/rump/librump/rumpvfs/rumpblk.c  3 Feb 2011 22:16:11 -0000       1.46
+++ sys/rump/librump/rumpvfs/rumpblk.c  5 Jul 2012 21:05:18 -0000
@@ -109,9 +109,7 @@ static struct rblkdev {
        char *rblk_path;
        int rblk_fd;
        int rblk_mode;
-#ifdef HAS_ODIRECT
        int rblk_dfd;
-#endif
        uint64_t rblk_size;
        uint64_t rblk_hostoffset;
        uint64_t rblk_hostsize;
@@ -368,7 +366,7 @@ rumpblk_init(void)
        for (i = 0; i < RUMPBLK_SIZE; i++) {
                mutex_init(&minors[i].rblk_memmtx, MUTEX_DEFAULT, IPL_NONE);
                cv_init(&minors[i].rblk_memcv, "rblkmcv");
-               minors[i].rblk_fd = -1;
+               minors[i].rblk_fd = minors[i].rblk_dfd = -1;
        }

        evcnt_attach_dynamic(&ev_io_total, EVCNT_TYPE_MISC, NULL,
@@ -501,6 +499,9 @@ static int
 backend_open(struct rblkdev *rblk, const char *path)
 {
        int error, fd;
+#ifdef HAS_ODIRECT
+       int dummy;
+#endif

        KASSERT(rblk->rblk_fd == -1);
        fd = rumpuser_open(path, O_RDWR, &error);
@@ -514,7 +515,7 @@ backend_open(struct rblkdev *rblk, const
                rblk->rblk_dfd = rumpuser_open(path,
                    O_RDONLY | O_DIRECT, &error);
                if (error) {
-                       close(fd);
+                       rumpuser_close(fd, &dummy);
                        return error;
                }
 #endif
@@ -525,13 +526,13 @@ backend_open(struct rblkdev *rblk, const
                rblk->rblk_dfd = rumpuser_open(path,
                    O_RDWR | O_DIRECT, &error);
                if (error) {
-                       close(fd);
+                       rumpuser_close(fd, &dummy);
                        return error;
                }
 #endif
        }

-       if (rblk->rblk_ftype == RUMPUSER_FT_REG) {
+       if (rblk->rblk_ftype == RUMPUSER_FT_REG && rblk->rblk_dfd != -1) {
                uint64_t fsize= rblk->rblk_hostsize, off= rblk->rblk_hostoffset;
                struct blkwin *win;
                int i, winsize;
@@ -591,12 +592,10 @@ backend_close(struct rblkdev *rblk)
        rumpuser_fsync(rblk->rblk_fd, &dummy);
        rumpuser_close(rblk->rblk_fd, &dummy);
        rblk->rblk_fd = -1;
-#ifdef HAS_ODIRECT
        if (rblk->rblk_dfd != -1) {
                rumpuser_close(rblk->rblk_dfd, &dummy);
                rblk->rblk_dfd = -1;
        }
-#endif

        return 0;
 }
\end{verbatim}}
